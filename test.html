<DOCTYPE html>
<html>
    <head>
        <title>Tic Tac Toe</title>
    </head>

    <body>

        <div class="yui3-skin-sam" id="console"></div>

        <script src="http://yui.yahooapis.com/3.8.1/build/yui/yui-min.js"></script>
        <script>

            YUI({
                modules: {
                    'tic-tac-toe-board': {
                        fullpath: 'Javascripts/tic-tac-toe-board.js',
                        requires: ['base-build', 'widget']
                    }
                }
            }).use('tic-tac-toe-board', 'test-console', function (Y) {
                "use strict";


                var testPossibilities = new Y.Test.Case({
                    name: 'possibilities() Tests',

                    'Array should have nine members that correspond to each of the nine x, y coordinates': function () {
                        var board = [['n', 'n', 'n'],
                                    ['n', 'n', 'n'],
                                    ['n', 'n', 'n']],

                            testGame = new Y.ticTacToeBoard,
                            literalListToEqual = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]],
                            result = testGame.possibleMoveLocations(board),
                            i,
                            j;
                            for(i = 0; i < literalListToEqual.length; i += 1) {
                                for(j = 0; j < literalListToEqual[i].length; j += 1) {
                                    Y.Assert.areSame(literalListToEqual[i][j], result[i][j]);
                                }
                            }
                    }
                }),

                filteringForAI = new Y.Test.Case({
                    name: 'AI Filtering Tests',

                    'Function should take an Array of boards and return an array of the boards where x is winning': function () {
                        var winningBoard, notWinningBoard, multiWinningBoard,

                            testGame = new Y.ticTacToeBoard;

                        winningBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'x', 'n'],
                                                                               ['n', 'o', 'n'],
                                                                               ['n', 'o', 'n']]);

                        notWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'o', 'x'],
                                                                                  ['n', 'n', 'n'],
                                                                                  ['n', 'n', 'n']]);


                        multiWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'o', 'x'],
                                                                                   ['x', 'x', 'n'],
                                                                                   ['n', 'n', 'n']]);

                        Y.Assert.areSame(1, (winningBoard.filterForWinX(winningBoard.projectAllPossibleXMoveBoardsThisTurn())).length);
                        Y.Assert.areSame(0, (notWinningBoard.filterForWinX(notWinningBoard.projectAllPossibleXMoveBoardsThisTurn())).length);
                        Y.Assert.areSame(3, (multiWinningBoard.filterForWinX(multiWinningBoard.projectAllPossibleXMoveBoardsThisTurn())).length);

                    },


                    'Function should take an Array of boards and return an array of the boards where o is winning': function () {

                        var winningBoard, notWinningBoard, multiWinningBoard,

                            testGame = new Y.ticTacToeBoard;

                        winningBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'o', 'n'],
                                                                               ['n', 'x', 'n'],
                                                                               ['n', 'x', 'n']]);

                        notWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'x', 'o'],
                                                                                  ['n', 'n', 'n'],
                                                                                  ['n', 'n', 'n']]);


                        multiWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'x', 'o'],
                                                                                    ['o', 'o', 'n'],
                                                                                    ['n', 'n', 'n']]);

                        Y.Assert.areSame(1, (winningBoard.filterForWinO(winningBoard.projectAllPossibleBoardsThisTurn())).length);
                        Y.Assert.areSame(0, (notWinningBoard.filterForWinO(notWinningBoard.projectAllPossibleBoardsThisTurn())).length);
                        Y.Assert.areSame(3, (multiWinningBoard.filterForWinO(multiWinningBoard.projectAllPossibleBoardsThisTurn())).length);

                    },

                    'filterAgainstWinForX should take a list of boards and not return the ones where X is winning': function () {

                        var winningBoardSeed,

                        testGame = new Y.ticTacToeBoard;

                        winningBoardSeed = testGame.makeBoardArrayFromSquareAttrs([['o', 'x', 'n'],
                                                                                   ['n', 'x', 'n'],
                                                                                   ['o', 'n', 'o']]);

                        Y.Assert.areSame(3, (winningBoardSeed.filterAgainstWinForX(winningBoardSeed.projectAllPossibleXMoveBoardsThisTurn()).length));

                    },

                    'filterForHighestOneToWinForX should take an array of empty boards and return no boards at all': function () {

                        var highestNumberOfOneToWinForX,
                            noOneToWins,
                            testGame = new Y.ticTacToeBoard;

                        noOneToWins = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                              ['n', 'n', 'n'],
                                                                              ['n', 'n', 'n']]);


                        Y.Assert.areSame(0, noOneToWins.filterForHighestOneToWinForX(noOneToWins.projectAllPossibleXMoveBoardsThisTurn()).length);
                    },

                    'filterForHighestOneToWinFor X should take an array of boards, some of the boards have one one to win row and return the boards which have on to win rows': function () {

                        var highestNumberOfOneToWinForX,
                            oneOneToWinPerBoard,
                            testGame = new Y.ticTacToeBoard;


                        oneOneToWinPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                                      ['n', 'n', 'n'],
                                                                                      ['n', 'o', 'o']]);

                        Y.Assert.areSame(4, oneOneToWinPerBoard.filterForHighestOneToWinForX(oneOneToWinPerBoard.projectAllPossibleXMoveBoardsThisTurn()).length);

                    },
                    'filterForHighestOneToWinFor X should take an array of boards, one of the boards has two rows with one two wins in each, it returns these boards': function () {

                        var twoOneToWinsPerBoard,
                            testGame = new Y.ticTacToeBoard;

                        twoOneToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                                       ['n', 'o', 'n'],
                                                                                       ['o', 'n', 'x']]);

                        Y.Assert.areSame(1, twoOneToWinsPerBoard.filterForHighestOneToWinForX(twoOneToWinsPerBoard.projectAllPossibleXMoveBoardsThisTurn()).length);
                    },

                    'filterAgainstOneToWinForX should take an array of empty boards and return what it was given': function () {


                        var noOneToWins,
                            testGame = new Y.ticTacToeBoard;

                        noOneToWins = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                              ['n', 'n', 'n'],
                                                                              ['n', 'n', 'n']]);


                        Y.Assert.areSame(9, noOneToWins.filterAgainstOneToWinForX(noOneToWins.projectAllPossibleXMoveBoardsThisTurn()).length);

                    },

                    'filterAgainstOneToWinForX should take an array of boards where some of the boards have one one to win row and return no boards with one to wins on them': function () {


                        var oneOneToWinPerBoard,
                            testGame = new Y.ticTacToeBoard;


                        oneOneToWinPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                                      ['n', 'n', 'o'],
                                                                                      ['n', 'n', 'n']]);

                        Y.Assert.areSame(1, oneOneToWinPerBoard.filterAgainstOneToWinForX(oneOneToWinPerBoard.projectAllPossibleXMoveBoardsThisTurn()).length);

                    },


                    'filterForHighestOneToWinForO should take an array of empty boards and return no boards at all': function () {

                        var noOneToWins,
                            testGame = new Y.ticTacToeBoard;

                        noOneToWins = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                              ['n', 'n', 'n'],
                                                                              ['n', 'n', 'n']]);


                        Y.Assert.areSame(0, noOneToWins.filterForHighestOneToWinForO(noOneToWins.projectAllPossibleBoardsThisTurn()).length);
                    },

                    'filterForHighestOneToWinFor O should take an array of boards, some of the boards have one one to win row and return the boards which have on to win rows': function () {

                        var oneOneToWinPerBoard,
                            testGame = new Y.ticTacToeBoard;


                        oneOneToWinPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'n'],
                                                                                      ['n', 'n', 'x'],
                                                                                      ['n', 'n', 'x']]);

                        Y.Assert.areSame(4, oneOneToWinPerBoard.filterForHighestOneToWinForO(oneOneToWinPerBoard.projectAllPossibleBoardsThisTurn()).length);

                    },


                    'filterForHighestOneToWinFor O should take an array of boards, one of the boards has two rows with one two wins in each, it returns these boards': function () {

                        var twoOneToWinsPerBoard,
                            testGame = new Y.ticTacToeBoard;

                        twoOneToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'n'],
                                                                                       ['n', 'x', 'n'],
                                                                                       ['x', 'n', 'o']]);

                        Y.Assert.areSame(1, twoOneToWinsPerBoard.filterForHighestOneToWinForO(twoOneToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
                    },

                    'filterForHighestTwoToWinForX should take an array from an empty board and return one board': function () {

                        var oneTwoToWin,
                            testGame = new Y.ticTacToeBoard;

                        oneTwoToWin = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                              ['n', 'n', 'n'],
                                                                              ['n', 'n', 'n']]);


                        Y.Assert.areSame(1, oneTwoToWin.filterForHighestTwoToWinForX(oneTwoToWin.projectAllPossibleXMoveBoardsThisTurn()).length);
                    },


                    'filterForHighestTwoToWinFor X should take an array of boards, some of the boards have two one to win rows and return the boards which have one to win rows': function () {

                        var fourTwoToWinFromBoard,
                            testGame = new Y.ticTacToeBoard;


                        fourTwoToWinFromBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                        ['n', 'o', 'n'],
                                                                                        ['n', 'n', 'n']]);

                        Y.Assert.areSame(4, fourTwoToWinFromBoard.filterForHighestTwoToWinForX(fourTwoToWinFromBoard.projectAllPossibleXMoveBoardsThisTurn()).length);

                    },
                    'filterForHighestTwoToWinFor X should take an array of boards, none of the boards has a two to win in it': function () {

                        var noTwoToWinsPerBoard,
                            testGame = new Y.ticTacToeBoard;

                        noTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'x'],
                                                                                      ['x', 'o', 'o'],
                                                                                      ['o', 'o', 'x']]);

                        Y.Assert.areSame(0, noTwoToWinsPerBoard.filterForHighestTwoToWinForX(noTwoToWinsPerBoard.projectAllPossibleXMoveBoardsThisTurn()).length);
                    },

                    'filterAgainstHighestTwoToWinFor X should take an array of boards, none of the boards has a two to win in it and return all possibilities': function () {

                        var noTwoToWinsPerBoard,
                            testGame = new Y.ticTacToeBoard;

                        noTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'x'],
                                                                                      ['x', 'o', 'o'],
                                                                                      ['o', 'o', 'x']]);

                        Y.Assert.areSame(1, noTwoToWinsPerBoard.filterAgainstHighestTwoToWinForX(noTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
                    },


                    'filterAgainstHighestTwoToWinFor X should take an array of boards, two boards should keep the two to wins lowest': function () {

                        var fourTwoToWinsPerBoard,
                            testGame = new Y.ticTacToeBoard;

                        fourTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'x'],
                                                                                        ['n', 'o', 'n'],
                                                                                        ['x', 'n', 'n']]);

                        Y.Assert.areSame(2, fourTwoToWinsPerBoard.filterAgainstHighestTwoToWinForX(fourTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
                    },

                    'filterAgainstHighestTwoToWinFor X should take an array of boards, eight boards should keep the two to wins lowest': function () {

                        var fourTwoToWinsPerBoard,
                            testGame = new Y.ticTacToeBoard;

                        fourTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                        ['n', 'x', 'n'],
                                                                                        ['n', 'n', 'n']]);

                        Y.Assert.areSame(8, fourTwoToWinsPerBoard.filterAgainstHighestTwoToWinForX(fourTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
                    },

                    'filterForHighestTwoToWinForO should take an array from an empty board and return one board': function () {

                        var oneTwoToWin,
                            testGame = new Y.ticTacToeBoard;

                        oneTwoToWin = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                              ['n', 'n', 'n'],
                                                                              ['n', 'n', 'n']]);


                        Y.Assert.areSame(1, oneTwoToWin.filterForHighestTwoToWinForO(oneTwoToWin.projectAllPossibleBoardsThisTurn()).length);
                    },


                    'filterForHighestTwoToWinForO should take an array of boards, some of the boards have two one to win rows and return the boards which have one to win rows': function () {

                        var fourTwoToWinFromBoard,
                            testGame = new Y.ticTacToeBoard;


                        fourTwoToWinFromBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                        ['n', 'x', 'n'],
                                                                                        ['n', 'n', 'n']]);

                        Y.Assert.areSame(4, fourTwoToWinFromBoard.filterForHighestTwoToWinForO(fourTwoToWinFromBoard.projectAllPossibleBoardsThisTurn()).length);

                    },

                    'filterForHighestTwoToWinForO should take an array of boards, none of the boards has a two to win in it': function () {

                        var noTwoToWinsPerBoard,
                            testGame = new Y.ticTacToeBoard;

                        noTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'o'],
                                                                                      ['o', 'x', 'x'],
                                                                                      ['x', 'x', 'o']]);

                        Y.Assert.areSame(0, noTwoToWinsPerBoard.filterForHighestTwoToWinForO(noTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
                    },

                    'projectAllMovesTwoTurnsAhead should take a board and return 1680 objects that each contain a far future board': function () {

                        var firstTurnBoard,
                            testGame = new Y.ticTacToeBoard;

                        firstTurnBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                 ['n', 'x', 'n'],
                                                                                 ['n', 'n', 'n']]);

                        Y.Assert.areSame(1680, firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn()).length);

                    },


                    'projectAllMovesTwoTurnsAhead should take a board and return objects that contain a far future board': function () {

                        var firstTurnBoard,
                            testGame = new Y.ticTacToeBoard;

                        firstTurnBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                 ['n', 'x', 'n'],
                                                                                 ['n', 'n', 'n']]);

                        Y.Assert.areSame('o', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][0][0]);
                        Y.Assert.areSame('x', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][0][1]);
                        Y.Assert.areSame('o', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][0][2]);

                        Y.Assert.areSame('x', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][1][0]);
                        Y.Assert.areSame('x', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][1][1]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][1][2]);

                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][2][0]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][2][1]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0][2][2]);

                    },


                    'projectAllMovesTwoTurnsAhead should take a board and return objects that contain a nextTurnBoard': function () {

                        var firstTurnBoard,
                            testGame = new Y.ticTacToeBoard;

                        firstTurnBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                 ['n', 'x', 'n'],
                                                                                 ['n', 'n', 'n']]);

                        Y.Assert.areSame('o', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[0][0]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[0][1]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[0][2]);

                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[1][0]);
                        Y.Assert.areSame('x', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[1][1]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[1][2]);

                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[2][0]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[2][1]);
                        Y.Assert.areSame('n', firstTurnBoard.projectAllMovesTwoTurnsAhead(firstTurnBoard.projectAllPossibleBoardsThisTurn())[0].nextTurnBoard[2][2]);

                    },

                    'findMoveForO should take a board near the end and choose the winning move': function () {

                        var endGame,
                            testGame = new Y.ticTacToeBoard;

                        endGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'x', 'o'],
                                                                          ['n', 'o', 'n'],
                                                                          ['n', 'n', 'n']]);

                        Y.Assert.areSame('o', (endGame.findMoveForO(endGame))[2][0]);

                    },

                    'findMoveForO should take a board near the end and block a winning move for x': function () {

                        var endGame,
                            testGame = new Y.ticTacToeBoard;

                        endGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'o'],
                                                                          ['n', 'o', 'x'],
                                                                          ['x', 'n', 'n']]);

                        Y.Assert.areSame('o', (endGame.findMoveForO(endGame))[1][0]);

                    },

                    'findMoveForO should take a board and pick the choice that minimizes two to wins on Xs side': function () {

                        var endGame,
                            testGame = new Y.ticTacToeBoard;

                        endGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'o'],
                                                                          ['n', 'n', 'x'],
                                                                          ['n', 'x', 'n']]);

                        Y.Assert.areSame('o', (endGame.findMoveForO(endGame))[1][1]);

                    },

                    'findMoveForO should take a board with no moves on it and place an o in the center': function () {

                        var cornerMoveGame,
                            testGame = new Y.ticTacToeBoard;

                        cornerMoveGame = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                 ['n', 'n', 'n'],
                                                                                 ['n', 'n', 'n']]);

                        Y.Assert.areSame('o', (cornerMoveGame.findMoveForO(cornerMoveGame))[1][1]);

                    },

                    'findMoveForO should take a board with a center move and make the first corner move': function () {

                        var centerMoveGame,
                            testGame = new Y.ticTacToeBoard;

                        centerMoveGame = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                 ['n', 'x', 'n'],
                                                                                 ['n', 'n', 'n']]);

                        Y.Assert.areSame('o', (centerMoveGame.findMoveForO(centerMoveGame))[0][0]);
                    },


                    'findMoveForO should take a board with a corner move and make the opposite corner move': function () {

                        var cornerMoveGame,
                            testGame = new Y.ticTacToeBoard;

                        cornerMoveGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                                 ['n', 'n', 'n'],
                                                                                 ['n', 'n', 'n']]);

                        Y.Assert.areSame('o', (cornerMoveGame.findMoveForO(cornerMoveGame))[2][2]);
                    }

                }),

                movesAheadVariation = new Y.Test.Case({

                    name: "Variation For Thinking Turns Ahead",

                    "projectAllMovesTwoTurnsAhead should absord the variation of turns left to be played": function () {


                    Y.Assert.areSame(1, 2);
                    }
                }); 

                new Y.Test.Console().render('#console');
                Y.Test.Runner.add(testPossibilities);
                Y.Test.Runner.add(filteringForAI);
                Y.Test.Runner.add(movesAheadVariation);
                Y.Test.Runner.run();
            });

        </script>
    </body>
