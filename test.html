<!doctype html>
<html>
    <head>
        <title>Tic Tac Toe</title>
    </head>

    <body>

        <div class="yui3-skin-sam" id="console"></div>

        <script src="http://yui.yahooapis.com/3.8.1/build/yui/yui-min.js"></script>
        <script>

/*global YUI: false */

YUI({
    modules: {
        'tic-tac-toe-board': {
            fullpath: 'Javascripts/tic-tac-toe-board.js',
            requires: ['base-build', 'widget']
        },
        'square-row-tools': {
            fullpath: 'Javascripts/square-row-tools.js'
        },
        'get-strand' : {
            fullpath: 'Javascripts/get-strand.js'
        },

        'check-board' : {
            fullpath: 'Javascripts/check-board.js'
        }
    }
}).use('tic-tac-toe-board', 'test-console', function (Y) {
    "use strict";


    var testPossibilities = new Y.Test.Case({
        name: 'possibilities() Tests',

        'Array should have nine members that correspond to each of the nine x, y coordinates': function () {
            var testGame = new Y.ticTacToeBoard(),
                board  = [['n', 'n', 'n'],
                          ['n', 'n', 'n'],
                          ['n', 'n', 'n']],


                literalListToEqual = [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]],
                result = Y.checkBoard.possibleMoveLocations(board),
                i,
                j;
            for (i = 0; i < literalListToEqual.length; i += 1) {
                for (j = 0; j < literalListToEqual[i].length; j += 1) {
                    Y.Assert.areSame(literalListToEqual[i][j], result[i][j]);
                }
            }
        }
    }),
        squareRowTools = new Y.Test.Case({
            name: 'Square-Row-Tool Tests',

            'Y.squareRowTools.getColumn should return a four item array for a three by four board': function () {

                var fourHighBoard = [['x', 'o', 'n'],
                                     ['n', 'n', 'n'],
                                     ['n', 'x', 'o'],
                                     ['n', 'o', 'n']];

                Y.Assert.areSame(Y.getStrand.column(0, fourHighBoard).length, 4, 'getColumn should count 4');
            },

            'Y.getStrand.highLeftDiagonal should return a four item array for a four by four board': function () {

                var fourWideFourTallBoard = [['x', 'o', 'n', 'x'],
                                             ['n', 'n', 'n', 'n'],
                                             ['n', 'x', 'o', 'n'],
                                             ['x', 'n', 'o', 'n']];

                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideFourTallBoard)[0], 'x', 'first should be x');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideFourTallBoard)[1], 'n', 'second should be n');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideFourTallBoard)[2], 'o', 'third should be o');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideFourTallBoard)[3], 'n', 'fourth should be n');
            },


            'Y.getStrand.highLeftDiagonal should return a three item array for a four by three board': function () {

                var fourWideThreeTallBoard = [['x', 'o', 'n', 'x'],
                                              ['n', 'n', 'n', 'n'],
                                              ['n', 'x', 'o', 'n']];

                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard)[0], 'x', 'first should be x');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard)[1], 'n', 'second should be n');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard)[2], 'o', 'third should be o');

                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard).length, 3, 'getColumn should count 3');
            },


            'Y.getStrand.highLeftDiagonal should return a three item array starting at the second column for a four by three board': function () {

                var fourWideThreeTallBoard = [['x', 'o', 'n', 'x'],
                                              ['n', 'n', 'n', 'n'],
                                              ['n', 'x', 'o', 'n']];

                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard, 1)[0], 'o', 'first should be x');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard, 1)[1], 'n', 'second should be n');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard, 1)[2], 'n', 'third should be o');

                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(fourWideThreeTallBoard, 1).length, 3, 'getColumn should count 3');
            },


            'Y.getStrand.highLeftDiagonal should return a three item array for a three by four board': function () {

                var threeWideFourTallBoard = [['x', 'o', 'n'],
                                              ['n', 'n', 'n'],
                                              ['n', 'x', 'o'],
                                              ['x', 'n', 'o']];

                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(threeWideFourTallBoard)[0], 'x', 'first should be x');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(threeWideFourTallBoard)[1], 'n', 'second should be n');
                Y.Assert.areSame(Y.getStrand.highLeftDiagonal(threeWideFourTallBoard)[2], 'o', 'third should be o');

                Y.Assert.areSame(3, Y.getStrand.highLeftDiagonal(threeWideFourTallBoard).length, 'getColumn should count 3');
            }

        }),



        filteringForAI = new Y.Test.Case({
            name: 'AI Filtering Tests',

            'Function should take an Array of boards and return an array of the boards where x is winning': function () {
                var winningBoard, notWinningBoard, multiWinningBoard,

                    testGame = new Y.ticTacToeBoard();

                winningBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'x', 'n'],
                                                                       ['n', 'o', 'n'],
                                                                       ['n', 'o', 'n']]);

                notWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'o', 'x'],
                                                                          ['n', 'n', 'n'],
                                                                          ['n', 'n', 'n']]);


                multiWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'o', 'x'],
                                                                           ['x', 'x', 'n'],
                                                                           ['n', 'n', 'n']]);

                Y.Assert.areSame(1, (winningBoard.filterForWinX(winningBoard.projectAllPossibleBoardsThisTurn(winningBoard, 'x'))).length);
                Y.Assert.areSame(0, (notWinningBoard.filterForWinX(notWinningBoard.projectAllPossibleBoardsThisTurn(notWinningBoard, 'x'))).length);
                Y.Assert.areSame(3, (multiWinningBoard.filterForWinX(multiWinningBoard.projectAllPossibleBoardsThisTurn(multiWinningBoard, 'x'))).length);

            },


            'Function should take an Array of boards and return an array of the boards where o is winning': function () {

                var winningBoard, notWinningBoard, multiWinningBoard,

                    testGame = new Y.ticTacToeBoard();

                winningBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'o', 'n'],
                                                                       ['n', 'x', 'n'],
                                                                       ['n', 'x', 'n']]);

                notWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'x', 'o'],
                                                                          ['n', 'n', 'n'],
                                                                          ['n', 'n', 'n']]);


                multiWinningBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'x', 'o'],
                                                                            ['o', 'o', 'n'],
                                                                            ['n', 'n', 'n']]);

                Y.Assert.areSame(1, (winningBoard.filterForWinO(winningBoard.projectAllPossibleBoardsThisTurn())).length);
                Y.Assert.areSame(0, (notWinningBoard.filterForWinO(notWinningBoard.projectAllPossibleBoardsThisTurn())).length);
                Y.Assert.areSame(3, (multiWinningBoard.filterForWinO(multiWinningBoard.projectAllPossibleBoardsThisTurn())).length);

            },

            'filterAgainstWinForX should take a list of boards and not return the ones where X is winning': function () {

                var winningBoardSeed,

                    testGame = new Y.ticTacToeBoard();

                winningBoardSeed = testGame.makeBoardArrayFromSquareAttrs([['o', 'x', 'n'],
                                                                           ['n', 'x', 'n'],
                                                                           ['o', 'n', 'o']]);

                Y.Assert.areSame(3, (winningBoardSeed.filterAgainstWinForX(winningBoardSeed.projectAllPossibleBoardsThisTurn(winningBoardSeed, 'x')).length));

            },


            'filterAgainstWinForO should take a list of boards and not return the ones where X is winning': function () {

                var winningBoardSeed,

                    testGame = new Y.ticTacToeBoard();

                winningBoardSeed = testGame.makeBoardArrayFromSquareAttrs([['x', 'o', 'n'],
                                                                           ['n', 'o', 'n'],
                                                                           ['x', 'n', 'x']]);

                Y.Assert.areSame(3, (winningBoardSeed.filterAgainstWinForO(winningBoardSeed.projectAllPossibleBoardsThisTurn()).length));

            },

            'filterForHighestOneToWinForX should take an array of empty boards and return no boards at all': function () {

                var highestNumberOfOneToWinForX,
                    noOneToWins,
                    testGame = new Y.ticTacToeBoard();

                noOneToWins = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                      ['n', 'n', 'n'],
                                                                      ['n', 'n', 'n']]);


                                                                      Y.Assert.areSame(0, noOneToWins.filterForHighestOneToWinForX(noOneToWins.projectAllPossibleBoardsThisTurn(noOneToWins, 'x')).length);
            },

            'filterForHighestOneToWinFor X should take an array of boards, some of the boards have one one to win row and return the boards which have on to win rows': function () {

                var highestNumberOfOneToWinForX,
                    oneOneToWinPerBoard,
                    testGame = new Y.ticTacToeBoard();


                oneOneToWinPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                              ['n', 'n', 'n'],
                                                                              ['n', 'o', 'o']]);

                Y.Assert.areSame(4, oneOneToWinPerBoard.filterForHighestOneToWinForX(oneOneToWinPerBoard.projectAllPossibleBoardsThisTurn(oneOneToWinPerBoard, 'x')).length);

            },
            'filterForHighestOneToWinFor X should take an array of boards, one of the boards has two rows with one two wins in each, it returns these boards': function () {

                var twoOneToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                twoOneToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                               ['n', 'o', 'n'],
                                                                               ['o', 'n', 'x']]);

                Y.Assert.areSame(1, twoOneToWinsPerBoard.filterForHighestOneToWinForX(twoOneToWinsPerBoard.projectAllPossibleBoardsThisTurn(twoOneToWinsPerBoard, 'x')).length);
            },

            'filterAgainstOneToWinForX should take an array of empty boards and return what it was given': function () {


                var noOneToWins,
                    testGame = new Y.ticTacToeBoard();

                noOneToWins = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                      ['n', 'n', 'n'],
                                                                      ['n', 'n', 'n']]);


                Y.Assert.areSame(9, noOneToWins.filterAgainstOneToWinForX(noOneToWins.projectAllPossibleBoardsThisTurn(noOneToWins, 'x')).length);

            },

            'filterAgainstOneToWinForX should take an array of boards where some of the boards have one one to win row and return no boards with one to wins on them': function () {


                var oneOneToWinPerBoard,
                    testGame = new Y.ticTacToeBoard();


                oneOneToWinPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                              ['n', 'n', 'o'],
                                                                              ['n', 'n', 'n']]);

                Y.Assert.areSame(1, oneOneToWinPerBoard.filterAgainstOneToWinForX(oneOneToWinPerBoard.projectAllPossibleBoardsThisTurn(oneOneToWinPerBoard, 'x')).length);

            },


            'filterAgainstOneToWinForO should take an array of empty boards and return what it was given': function () {


                var noOneToWins,
                    testGame = new Y.ticTacToeBoard();

                noOneToWins = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                      ['n', 'n', 'n'],
                                                                      ['n', 'n', 'n']]);


                Y.Assert.areSame(9, noOneToWins.filterAgainstOneToWinForO(noOneToWins.projectAllPossibleBoardsThisTurn()).length);

            },

            'filterAgainstOneToWinForO should take an array of boards where some of the boards have one one to win row and return no boards with one to wins on them': function () {


                var oneOneToWinPerBoard,
                    testGame = new Y.ticTacToeBoard();


                oneOneToWinPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'n'],
                                                                              ['n', 'n', 'x'],
                                                                              ['n', 'n', 'n']]);

                Y.Assert.areSame(1, oneOneToWinPerBoard.filterAgainstOneToWinForO(oneOneToWinPerBoard.projectAllPossibleBoardsThisTurn()).length);

            },

            'filterForHighestOneToWinForO should take an array of empty boards and return no boards at all': function () {

                var noOneToWins,
                    testGame = new Y.ticTacToeBoard();

                noOneToWins = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                      ['n', 'n', 'n'],
                                                                      ['n', 'n', 'n']]);


                Y.Assert.areSame(0, noOneToWins.filterForHighestOneToWinForO(noOneToWins.projectAllPossibleBoardsThisTurn()).length);
            },

            'filterForHighestOneToWinFor O should take an array of boards, some of the boards have one one to win row and return the boards which have on to win rows': function () {

                var oneOneToWinPerBoard,
                    testGame = new Y.ticTacToeBoard();


                oneOneToWinPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'n'],
                                                                              ['n', 'n', 'x'],
                                                                              ['n', 'n', 'x']]);

                Y.Assert.areSame(4, oneOneToWinPerBoard.filterForHighestOneToWinForO(oneOneToWinPerBoard.projectAllPossibleBoardsThisTurn()).length);

            },


            'filterForHighestOneToWinFor O should take an array of boards, one of the boards has two rows with one two wins in each, it returns these boards': function () {

                var twoOneToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                twoOneToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'n'],
                                                                               ['n', 'x', 'n'],
                                                                               ['x', 'n', 'o']]);

                Y.Assert.areSame(1, twoOneToWinsPerBoard.filterForHighestOneToWinForO(twoOneToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
            },



            'filterForHighestTwoToWinForX should take an array from an empty board and return one board': function () {

                var oneTwoToWin,
                    testGame = new Y.ticTacToeBoard();

                oneTwoToWin = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                      ['n', 'n', 'n'],
                                                                      ['n', 'n', 'n']]);


                Y.Assert.areSame(1, oneTwoToWin.filterForHighestTwoToWinForX(oneTwoToWin.projectAllPossibleBoardsThisTurn(oneTwoToWin, 'x')).length);
            },


            'filterForHighestTwoToWinFor X should take an array of boards, some of the boards have two one to win rows and return the boards which have one to win rows': function () {

                var fourTwoToWinFromBoard,
                    testGame = new Y.ticTacToeBoard();


                fourTwoToWinFromBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                ['n', 'o', 'n'],
                                                                                ['n', 'n', 'n']]);

                Y.Assert.areSame(4, fourTwoToWinFromBoard.filterForHighestTwoToWinForX(fourTwoToWinFromBoard.projectAllPossibleBoardsThisTurn(fourTwoToWinFromBoard, 'x')).length);

            },
            'filterForHighestTwoToWinFor X should take an array of boards, none of the boards has a two to win in it': function () {

                var noTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                noTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'x'],
                                                                              ['x', 'o', 'o'],
                                                                              ['o', 'o', 'x']]);

                Y.Assert.areSame(0, noTwoToWinsPerBoard.filterForHighestTwoToWinForX(noTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn(noTwoToWinsPerBoard, 'x')).length);
            },

            'filterAgainstHighestTwoToWinFor X should take an array of boards, none of the boards has a two to win in it and return all possibilities': function () {

                var noTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                noTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'x'],
                                                                              ['x', 'o', 'o'],
                                                                              ['o', 'o', 'x']]);

                Y.Assert.areSame(1, noTwoToWinsPerBoard.filterAgainstHighestTwoToWinForX(noTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
            },


            'filterAgainstHighestTwoToWinFor X should take an array of boards, two boards should keep the two to wins lowest': function () {

                var fourTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                fourTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'x'],
                                                                                ['n', 'o', 'n'],
                                                                                ['x', 'n', 'n']]);

                Y.Assert.areSame(2, fourTwoToWinsPerBoard.filterAgainstHighestTwoToWinForX(fourTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
            },

            'filterAgainstHighestTwoToWinFor X should take an array of boards, eight boards should keep the two to wins lowest': function () {

                var fourTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                fourTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                ['n', 'x', 'n'],
                                                                                ['n', 'n', 'n']]);

                Y.Assert.areSame(8, fourTwoToWinsPerBoard.filterAgainstHighestTwoToWinForX(fourTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
            },


            'filterAgainstHighestTwoToWinFor O should take an array of boards, none of the boards has a two to win in it and return all possibilities': function () {

                var noTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                noTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'o'],
                                                                              ['o', 'x', 'x'],
                                                                              ['x', 'x', 'o']]);

                Y.Assert.areSame(1, noTwoToWinsPerBoard.filterAgainstHighestTwoToWinForO(noTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn(noTwoToWinsPerBoard, 'x')).length);
            },


            'filterAgainstHighestTwoToWinFor O should take an array of boards, two boards should keep the two to wins lowest': function () {

                var fourTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                fourTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'o'],
                                                                                ['n', 'x', 'n'],
                                                                                ['o', 'n', 'n']]);

                Y.Assert.areSame(2, fourTwoToWinsPerBoard.filterAgainstHighestTwoToWinForO(fourTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn(fourTwoToWinsPerBoard, 'x')).length);
            },

            'filterAgainstHighestTwoToWinFor O should take an array of boards, eight boards should keep the two to wins lowest': function () {

                var fourTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                fourTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                ['n', 'o', 'n'],
                                                                                ['n', 'n', 'n']]);

                Y.Assert.areSame(8, fourTwoToWinsPerBoard.filterAgainstHighestTwoToWinForO(fourTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn(fourTwoToWinsPerBoard, 'x')).length);
            },

            'filterForHighestTwoToWinForO should take an array from an empty board and return one board': function () {

                var oneTwoToWin,
                    testGame = new Y.ticTacToeBoard();

                oneTwoToWin = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                      ['n', 'n', 'n'],
                                                                      ['n', 'n', 'n']]);


                Y.Assert.areSame(1, oneTwoToWin.filterForHighestTwoToWinForO(oneTwoToWin.projectAllPossibleBoardsThisTurn()).length);
            },


            'filterForHighestTwoToWinForO should take an array of boards, some of the boards have two one to win rows and return the boards which have one to win rows': function () {

                var fourTwoToWinFromBoard,
                    testGame = new Y.ticTacToeBoard();


                fourTwoToWinFromBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                                ['n', 'x', 'n'],
                                                                                ['n', 'n', 'n']]);

                Y.Assert.areSame(4, fourTwoToWinFromBoard.filterForHighestTwoToWinForO(fourTwoToWinFromBoard.projectAllPossibleBoardsThisTurn()).length);

            },

            'filterForHighestTwoToWinForO should take an array of boards, none of the boards has a two to win in it': function () {

                var noTwoToWinsPerBoard,
                    testGame = new Y.ticTacToeBoard();

                noTwoToWinsPerBoard = testGame.makeBoardArrayFromSquareAttrs([['o', 'n', 'o'],
                                                                              ['o', 'x', 'x'],
                                                                              ['x', 'x', 'o']]);

                Y.Assert.areSame(0, noTwoToWinsPerBoard.filterForHighestTwoToWinForO(noTwoToWinsPerBoard.projectAllPossibleBoardsThisTurn()).length);
            },

            'checkOppositeCornerHazardAgainstO should take a board with an x move in the top left corner, an o move in the center, an x move in the opposite corner and return true, when middle of the top is an o move and there are five turns left in the game': function () {


                var doubleCornerXBoard,
                    testGame = new Y.ticTacToeBoard();

                doubleCornerXBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'o', 'n'],
                                                                             ['n', 'o', 'n'],
                                                                             ['n', 'n', 'x']]);

                Y.Assert.areSame(true, doubleCornerXBoard.checkOppositeCornerHazardAgainstO(doubleCornerXBoard));
                Y.Assert.areSame(5, Y.checkBoard.possibleMoveLocations(doubleCornerXBoard).length);
            },


            'checkOppositeCornerHazardAgainstO should take a board with an x move in the top right corner and in the opposite corner and return true when an o move is on the right side of the middle row and there are five turns left in the game': function () {

                var doubleCornerXBoard,
                    testGame = new Y.ticTacToeBoard();

                doubleCornerXBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'x'],
                                                                             ['n', 'o', 'o'],
                                                                             ['x', 'n', 'n']]);

                Y.Assert.areSame(true, doubleCornerXBoard.checkOppositeCornerHazardAgainstO(doubleCornerXBoard));
                Y.Assert.areSame(5, Y.checkBoard.possibleMoveLocations(doubleCornerXBoard).length);

            },


            'checkOppositeCornerHazardAgainstO should take a board with an x move in the top left corner, an o move in the center, an x move in the opposite corner and return true, when the left of the middle row is an o move and there are five turns left in the game': function () {


                var doubleCornerXBoard,
                    testGame = new Y.ticTacToeBoard();

                doubleCornerXBoard = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                             ['o', 'o', 'n'],
                                                                             ['n', 'n', 'x']]);

                Y.Assert.areSame(true, doubleCornerXBoard.checkOppositeCornerHazardAgainstO(doubleCornerXBoard));
                Y.Assert.areSame(5, Y.checkBoard.possibleMoveLocations(doubleCornerXBoard).length);
            },


            'checkOppositeCornerHazardAgainstO should take a board with an x move in the top right corner and in the opposite corner and return true when an o move is the middle of the bottom row': function () {

                var doubleCornerXBoard,
                    testGame = new Y.ticTacToeBoard();

                doubleCornerXBoard = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'x'],
                                                                             ['n', 'o', 'n'],
                                                                             ['x', 'o', 'n']]);

                Y.Assert.areSame(true, doubleCornerXBoard.checkOppositeCornerHazardAgainstO(doubleCornerXBoard));
                Y.Assert.areSame(5, Y.checkBoard.possibleMoveLocations(doubleCornerXBoard).length);

            },

            'filterAgainstOppositeCornerHazardForO should take an array of boards where xs are in opposite corners and should only return the board that forces a move out of the corner': function () {

                var dangerousArraySeed,
                    testGame = new Y.ticTacToeBoard();

                dangerousArraySeed = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                            ['n', 'o', 'n'],
                                                                            ['n', 'n', 'x']]);

                Y.Assert.areSame('o', dangerousArraySeed.filterAgainstOppositeCornerHazardForO(dangerousArraySeed.projectAllPossibleBoardsThisTurn())[0][0][1]);

            },

            'findMoveForO should take a board near the end and choose the winning move': function () {

                var endGame,
                    testGame = new Y.ticTacToeBoard();

                endGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'x', 'o'],
                                                                  ['n', 'o', 'n'],
                                                                  ['n', 'n', 'n']]);

                Y.Assert.areSame('o', (endGame.findMoveForO(endGame))[2][0]);

            },

            'findMoveForO should take a board near the end and block a winning move for x': function () {

                var endGame,
                    testGame = new Y.ticTacToeBoard();

                endGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'o'],
                                                                  ['n', 'o', 'x'],
                                                                  ['x', 'n', 'n']]);

                Y.Assert.areSame('o', (endGame.findMoveForO(endGame))[1][0]);

            },

            'findMoveForO should take a board and pick the choice that minimizes two to wins on Xs side': function () {

                var endGame,
                    testGame = new Y.ticTacToeBoard();

                endGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'o'],
                                                                  ['n', 'n', 'x'],
                                                                  ['n', 'x', 'n']]);

                Y.Assert.areSame('o', (endGame.findMoveForO(endGame))[1][1]);

            },

            'findMoveForO should take a board with no moves on it and place an o in the center': function () {

                var cornerMoveGame,
                    testGame = new Y.ticTacToeBoard();

                cornerMoveGame = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                         ['n', 'n', 'n'],
                                                                         ['n', 'n', 'n']]);

                Y.Assert.areSame('o', (cornerMoveGame.findMoveForO(cornerMoveGame))[1][1]);

            },

            'findMoveForO should take a board with a center move and make the first corner move': function () {

                var centerMoveGame,
                    testGame = new Y.ticTacToeBoard();

                centerMoveGame = testGame.makeBoardArrayFromSquareAttrs([['n', 'n', 'n'],
                                                                         ['n', 'x', 'n'],
                                                                         ['n', 'n', 'n']]);

                Y.Assert.areSame('o', (centerMoveGame.findMoveForO(centerMoveGame))[0][0]);
            },


            'findMoveForO should take a board with a corner move and make the center move': function () {

                var cornerMoveGame,
                    testGame = new Y.ticTacToeBoard();

                cornerMoveGame = testGame.makeBoardArrayFromSquareAttrs([['x', 'n', 'n'],
                                                                         ['n', 'n', 'n'],
                                                                         ['n', 'n', 'n']]);

                Y.Assert.areSame('o', (cornerMoveGame.findMoveForO(cornerMoveGame))[1][1]);
            },


        });

    new Y.Test.Console().render('#console');
    Y.Test.Runner.add(testPossibilities);
    Y.Test.Runner.add(filteringForAI);
    Y.Test.Runner.add(squareRowTools);
    Y.Test.Runner.run();
});

        </script>
    </body>
</html>
